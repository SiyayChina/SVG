# 点击展开示例

## 核心代码

核心代码和预览文件请参考资料包中的其他文件
其中后缀为svg的文件是我用于在本地编辑代码的文件
后缀为html的两个文件是用于在浏览器中预览的文件
以及准备培训内容时使用的备份文件

## 设计逻辑

本动画设计的运行流程为：
首先按顺序叠加加载渐变背景/内容层/封面层(**后来居上**)
然后通过不可见的矩形检测用户的点击动作
检测到点击动作后，封面层淡出，然后**封面层**逐渐放大到全尺寸(970.361%)
此时**封面层会把svg顶开**，露出本来的svg高度无法容纳的很长的**内容层**图片
然而我们的手机视图只会保持在100%宽高，我们视觉上会认为是**内容层**变长展开了

## 分段说明

### 内容层

内容层即点击后显示并展开的一层，由于在封面层之下显示，一般写在封面层前面

本推文的内容层是简单的图片连接

### 封面层

封面层写在内容层之后是为了将其堆叠到内容层上(可以理解成把一张张纸放在桌面上后来居上)

#### 元素实体

##### 背景

```html

<svg width="100%" height="100%">
    <rect fill="transparent" width="100%" height="100%" x="0%" y="0%"></rect>
    <foreignObject x="0%" y="0%" width="100%" height="100%">
        <svg viewBox="0 0 375 663.75"
            style="background-image: linear-gradient(rgb(42, 70, 137) 0%, rgb(101, 174, 157) 100%);"
            class="js_darkmode__bg__0 js_darkmode__0"
            data-style="background-image: linear-gradient(rgb(42, 70, 137) 0%, rgb(101, 174, 157) 100%);"></svg>
    </foreignObject>
</svg>

```

这一部分是构造了一个矩形渐变色背景(为了防止由于网络问题等问题导致加载速度过慢引起用户的困惑)

##### 动作捕捉

```html

<rect style="pointer-events: auto;opacity: 0;" width="100%"
    height="100%">
    <animate from="0" to="0" dur="0" begin="click + 0.1s" fill="freeze"
        attributeName="width"></animate>
</rect>

```

为了捕捉鼠标的点击动作增加的不影响视觉的rect(矩形)元素

##### 背景图片

即封面图

#### 用户交互

##### 动画

```html

<animate fill="freeze" attributeName="opacity" begin="click" from="1" to="0"
    dur="0.5" restart="never"></animate>
<animate fill="freeze" attributeName="width" begin="click + 0.5s" dur="13"
    keyTimes="0;0;0.0769;0.1538;0.2308;0.3077;0.3846;0.4615;0.5385;0.6154;0.6923;0.7692;0.8462;0.9231;1"
    values="100%;100%;361.9784%;361.9784%;445.9989%;445.9989%;531.1703%;531.1703%;610.0114%;610.0114%;679.6447%;679.6447%;741.7968%;741.7968%;970.361%"
    restart="never" calcMode="spline"
    keySplines="0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1;0.42 0 0.58 1"><animate>

```

先将封面由完全不透明变为完全透明
然后按照规划好的样条逐步展开内容页(实际上是放大封面页)

## 要点说明

### 不可视矩形检测交互动作的逻辑

在封面层的最外层svg标签中

```html

<svg width="100%" xmlns="http://www.w3.org/2000/svg"
    style="transform: rotateZ(0deg);display: block;pointer-events: none;width: 100%;max-width: none !important;"
    viewBox="0 0 375 663.75" opacity="1">
    ···
</svg>

```

有一个关键的CSS属性**pointer-events**
它的值被设定为了**none**

当该属性设置为none时，它将不允许本svg标签内所有元素检测鼠标动作，换句话说，鼠标的动作会**穿透**这些元素作用于其他可以检测到鼠标动作的元素(即使这个元素从空间上被压在了下面)

当该属性设置为none的svg组件的子级(后代元素)中有任何元素的该属性不是none，该组件可以捕捉鼠标事件(鼠标事件可以指向后代元素)，然后触发其父级元素的事件侦听器

也就是说，**本动画中检测到鼠标事件的组件是不可见的rect元素，而非最外层的整个svg**
或者说，我们把rect删除的话，我们的动画就没办法启动了(因为animate标签中的click动作无法被检测到)

但在本动画中，这个rect似乎没什么卵用(你可以把最外层svg的pointer-events改为auto，删去rect，动画依然可以启动)是因为我们没有刻意设计rect的大小范围，他是全尺寸的，点它和点整个svg没啥区别

这就涉及到了**热区**这个概念，假如我并不想让用户随便点击图片的任何地方都能触发动画，**而是只限制到图片的某个区域或者范围(通常是一个按钮或者提示文字附近)，就必须引入不可视图形元素标记这个热区**

实现方式也很简单，只需要规定好这个矩形的位置和大小就好了

当时我做这个推文懒得做热区了，但是又想搞一个教学案例，就先这样了(\^0\^)
